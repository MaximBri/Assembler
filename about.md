# Assembler (TASM)

## Директивы: показывают, с какой модели процессоров должен поддерживаться код.

Примеры: `.8086`, `.186`, `.286`, `.386`

## Режимы работы процессора:

1. **16 разрядов** - режим реальных адресов
2. **32 разряда** - защищённый режим
3. **64 разряда** - lond mode, в нём работаю почти все современные процессоры

## Регистры: различаются по назначению:

- Общего назначения: AX, BX, CX, DX - используются для любых видов данных, но есть некоторые рекомендации: CX - счётчик для цикла, AX - арифметические операции.
  `Все они разделяются на *H и *L`
- Указатели: SP, BP, IP
- Индексные: SI, DI
- Сегментные: CS, DS, SS, ES, GS, FS: CS - сегмент кода, DS - сегмент данных, SS - сегмент стека, ES, GS, FS - сегменты доп. данных
- Управления: FLAGS

Регистры - маленькие ячейки памяти на процессоре

## Модели:

- **TINY**. Код, данные и стек размещаются в одном сегменте размером до **_64 Кб_**. Эта модель чаще всего используется при написании на ассемблере небольших программ. 1
- **SMALL**. Код размещается в одном сегменте, а данные и стек — в другом (для их описания могут применяться разные сегменты, но объединённые в одну группу).
- **COMPACT**. Код размещается в одном сегменте, а для хранения данных могут использоваться несколько сегментов, так что для обращения к данным требуется указывать сегмент и смещение (данные дальнего типа).
- **MEDIUM**. Код размещается в нескольких сегментах, а все данные — в одном, поэтому для доступа к данным используется только смещение, а вызовы подпрограмм применяют команды дальнего вызова процедуры.
- **LARGE** и **HUGE**. И код, и данные могут занимать несколько сегментов.
- **FLAT**. То же, что и `TINY`, но используются 32-битные сегменты, так что максимальный размер сегмента, содержащего и данные, и код, и стек, — **_4 Мб_**.

## Типы данных:

- `db` - 1 байт
- `dw` - 2 байта
- `dd` - 4 байта
- `dq` - 8 байтов
- `dt` - 10 байтов

## Массивы:

`words dw 100 dup(0)` - массив из 100 элементов (2 байт), заполненный нулями

## Команды:

- `mov` - команда пересылки данных.
  `mov ax, bx` - копируем в ax данные из bx
- `add` - сумма
- `shr` - команда логического сдвига вправо. Первый операнд - сдвигаемое значение, второй - количество бит, на которое нужно осуществить сдвиг
- `sub` - разность
- `dec` - уменьшает значение указанного операнда на единицу
- `inc` - увеличивает значение указанного операнда на единицу
- `div` - деление без знака
- `idiv` - деление со знаком
- `mul` - умножение без знака
- `imul` - умножение со знаком
- `cbw` - конвертирует `al` в `ax`
- `lea` - помещает адрес источника в назначение: `lea dx, InputBuffer`
- `loop` - команда организации цикла. Из CX вычитается единица и его значение сравнивается с 0. Если регистр не равен 0, то выполняется переход к указанной метке.
- `xor` - выполняет поразрядную операцию исключающего ИЛИ. При этом возвращается 1, если соответствующие разряды обоих операндов не равны друг другу, а если равны — 0.
- `or` - выполняет операцию или.
- `je` - проверяет флаг ZF, если 1, то переход к метке: `je word_end`
- `jz` - выполняет переход к метке, если флаг нуля установлен
- `jne` - проверяет флаг ZF, если 0, то переход к метке: `jne word_end`
- `lodsb` - читает байт из строки по адресу DS:SI в регистр AL. После выполнения команды, регистр SI увеличивается на 1, если флаг DF = 0, или уменьшается на 1, если DF = 1.
- `int ***`:

  - 00h — завершение работы программы;
  - 01h — ввод символа с ожиданием и эхосопровождением. На выходе в AL — ACSII-код символа;
  - 02h — вывод символа. На входе в DL — ACSII-код символа;
  - 05h — вывод символа на принтер. На входе в DL — ACSII-код символа;
  - 07h — ввод символа с ожиданием и эхосопровождением;
  - 09h — вывод строки на экран. На входе — ds
    = адрес строки с символом $ на конце;
  - 0ah — ввод строки с клавиатуры. На входе ds
    = адрес буфера с форматом: 1 байт — размер буфера для ввода (формирует пользователь), 2 байт — число фактически введённых символов (заполняет система по окончанию ввода — нажатию Enter (0dh), этот символ не считает), 3 байт и далее — введённая строка с символом 0dh на конце. На выходе — введённая строка в буфере; 3
    0bh — проверка состояния буфера клавиатуры. На выходе AL=0 — буфер пуст, AL=offh — в буфере есть символы.

### Примеры:

`imul 2` - значение запишется в `ax`, более понятная запись: `imul ax, 2`

## Комментарии:

`; Это комментарий`

## Создание сегментов:

Есть 2 формата записи:

- Первый

```
.data
    s db 'Hello, world$'
```

- Второй

```
data segment
    s db 'Hello, world$'
data ends
```

**Данные варианты эквивалентны!**

**Разрядность** - размер регистров, адресов. Может принимать 2 значения: USE16 - 16 бит (по умолчанию), USE32 - 32 бита

**Выравнивание** - на границе какого адреса может начинаться сегмент. Возможные значения:

- `byte` - по любому адресу
- `word` - кратны 2
- `dword` - кратны 4
- `para` - кратны 16
- `page` - кратны 256

**Класс сегмента** - порядок следования сегментов в памяти

**Тип** - как комбиниовать сегменты с одинаковым именем. Возможные варианты:

- `PUBLIC` - все сегменты с одинаковым именем будут объединены в один
- `PRIVATE` - не будут объединяться в один (по умолчанию)
- `STACK` - определяет сегмент стека программы

## Группы:

```
DGROUP group data1, data2, data3

data1 SEGMENT
;...
data1 ends
...
```

## Простейший вывод

Строки

```
mov dx, 5
mov ah, 09h
int 21h
```

Символа

```
mov dl, ' '
mov ah, 02h ; выводим символ
int 21h
```

## Завершение программы с кодом 0:

```
mov ax, 4C00h
int 21h
```
